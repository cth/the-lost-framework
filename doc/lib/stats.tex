% This LaTeX document was generated using the LaTeX backend of PlDoc,
% The SWI-Prolog documentation system



\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%
\%
\% NOM ET VERSION :
\%
\% \file{stats.pl} -- Version 0.0
\%
\% GOAL :
\% Computation of several statistics
\%
\% HISTORIQUE :
\% M.P 10/03/2010
\%
\% DESCRIPTION :
\%
\%\%\%\%

\Sneck{} lost_include_api(interface).

\%\% stats(+Data_Type,+Options,+Data,?Result)
\%\% stats(+Data_Type,+Options,+Data,+Input_Counting,-Past,?Result)
\%
\% Computation of statistics given a set of Data
\%
\% Assumption: Data format corresponds to the kind of statistics that you compute
\% List of nucleotids for nucleotids-codon stats
\% List of AminoAcids for Amino stats
\% List of Ranges for Length stats computation
\% Option = Order

\begin{center}
\% Type nucleotide, codon, amino_acid
stats(Type,Options,Data,Input_Counting,Result) \Sneck{}
member(Type,[nucleotide,codon,amino_acid]),
var(Input_Counting),
!,
(member(order(N),Options) \Sifthen{}
true
;
N =0
),
(member(past(Past),Options) \Sifthen{}
Data = New_Data
;
check_or_fail(build_past(N,Data,Past-Past,New_Data),
stats_error('Data too short for the order')
)
),
init_counting(Type,N,Init_Counting),
stats_rec(New_Data,Past,Init_Counting ,Result).
\end{center}

\begin{center}
stats(Type,Options,Data,Input_Counting,Result) \Sneck{}
member(Type,[nucleotide,codon,amino_acid]),
!,
(member(order(N),Options) \Sifthen{}
true
;
N =0
),
(member(past(Past),Options) \Sifthen{}
Data = New_Data
;
check_or_fail(build_past(N,Data,Past-Past,New_Data),
stats_error('Data too short for the order')
)
),
stats_rec(New_Data,Past,Input_Counting,Result).
\end{center}

\% Stats that records the past

\begin{center}
stats(Type,Options,Data,Input_Counting,Past_Final,Result) \Sneck{}
member(Type,[nucleotide,codon,amino_acid]),
var(Input_Counting),
!,
(member(order(N),Options) \Sifthen{}
true
;
N =0
),
(member(past(Past),Options) \Sifthen{}
Data = New_Data
;
check_or_fail(build_past(N,Data,Past-Past,New_Data),
stats_error('Data too short for the order')
)
),
init_counting(Type,N,Init_Counting),
stats_rec(New_Data,Past,Init_Counting,Past_Final,Result).
\end{center}

\begin{center}
stats(Type,Options,Data,Input_Counting,Past_Final,Result) \Sneck{}
member(Type,[nucleotide,codon,amino_acid]),
!,
(member(order(N),Options) \Sifthen{}
true
;
N =0
),
(member(past(Past),Options) \Sifthen{}
Data = New_Data
;
check_or_fail(build_past(N,Data,Past-Past,New_Data),
stats_error('Data too short for the order')
)
),
stats_rec(New_Data,Past,Input_Counting,Past_Final,Result).
\end{center}

\begin{quote}
stats(length,Ranges,Result) \Sneck{}
stats_length(Ranges,[],Result).
\end{quote}

\% Recursive call

\begin{quote}
stats_rec([],_Past,Result,Result) \Sneck{}
!.
\end{quote}

\begin{quote}
stats_rec([Datum{\tt\string|}Rest_Data],Past,Input_Counting,Result) \Sneck{}
update_counting(Datum,Past,Input_Counting,Input_Counting2),
(Past = [] \Sifthen{}
true
;
Past = [_{\tt\string|}Rest_Past],
append(Rest_Past,[Datum],New_Past)
),
stats_rec(Rest_Data,New_Past,Input_Counting2,Result).
\end{quote}

\% Recursive call when the pas is recorded

\begin{quote}
stats_rec([],Past,Result,Past,Result) \Sneck{}
!.
\end{quote}

\begin{quote}
stats_rec([Datum{\tt\string|}Rest_Data],Past,Input_Counting,Past_Final,Result) \Sneck{}
update_counting(Datum,Past,Input_Counting,Input_Counting2),
(Past = [] \Sifthen{}
true
;
Past = [_{\tt\string|}Rest_Past],
append(Rest_Past,[Datum],New_Past)
),
stats_rec(Rest_Data,New_Past,Input_Counting2,Past_Final,Result).
\end{quote}

\% Recursive call to compute statistics on the length distribution

\begin{quote}
stats_length([],Result,Result) \Sneck{}
!.
\end{quote}

\begin{quote}
stats_length([[Min,Max]{\tt\string|}Ranges],Counting,Result) \Sneck{}
Length is Max-Min+1,
update_length(Length,Counting,Counting_New),
stats_length(Ranges,Counting_New,Result).
\end{quote}

\%---
\% Utils stats
\%---

\% init_counting
\%--------
\% Remark: Exponential explosion here: take care to select a
\% reasonable order (especially for codon type)

\begin{quote}
init_counting(Type,0,[([],Init_List)]) \Sneck{}
!,
get_init(Type,Init_List).
\end{quote}

\begin{quote}
init_counting(Type,Order,Init_List) \Sneck{}
findall(Res,init_counting_rec(Type,Order,Res),Init_List).
\end{quote}

\begin{quote}
init_counting_rec(Type,1,([Past],Init_List)) \Sneck{}
!,
get_past(Type,Past),
get_init(Type,Init_List).
\end{quote}

\begin{quote}
init_counting_rec(Type,Order,([Past{\tt\string|}Rest],Nuc_Init)) \Sneck{}
get_past(Type,Past),
Order1 is Order-1,
init_counting_rec(Type,Order1,(Rest,Nuc_Init)).
\end{quote}

\% update_counting(++Datum,++Past,++Input_Counting,--Counting_Update)
\% Remark: failed if the past is not in Input_Counting
\% Reminder: format of Input Counting Elt: (Past,[(Values,Count),Values,Count), ...])

\begin{quote}
update_counting(_Datum,_Past,[],[]) \Sneck{}
!,
fail.
\end{quote}

\begin{quote}
update_counting(Datum,Past,[(Past,Counting){\tt\string|}Rest],[(Past,Counting_Update){\tt\string|}Rest]) \Sneck{}
!,
update_counting_2(Datum,Counting,Counting_Update).
\end{quote}

\begin{quote}
update_counting(Datum,Past,[Head{\tt\string|}Rest],[Head{\tt\string|}Rest_Update]) \Sneck{}
!,
update_counting(Datum,Past,Rest,Rest_Update).
\end{quote}

\% Phase 2 of counting

\begin{quote}
update_counting_2([],[]) \Sneck{}
!,
fail.
\end{quote}

\begin{quote}
update_counting_2(Datum,[(Datum,Count){\tt\string|}Rest],[(Datum,New_Count){\tt\string|}Rest])\Sneck{}
!,
New_Count is Count+1.
\end{quote}

\begin{quote}
update_counting_2(Datum,[Head{\tt\string|}Rest],[Head{\tt\string|}Rest_Update]) \Sneck{}
!,
update_counting_2(Datum,Rest,Rest_Update).
\end{quote}

\% update_length(++Length,++Couting,--Counting_New).

\begin{quote}
update_length(Length,[],[(Length,1)]) \Sneck{}
!.
\end{quote}

\begin{quote}
update_length(Length,[(Length,Count){\tt\string|}Rest],[(Length,New_Count){\tt\string|}Rest]) \Sneck{}
!,
New_Count is Count+1.
\end{quote}

\begin{quote}
update_length(Length,[(Length_Below,Count){\tt\string|}Rest],[(Length_Below,Count){\tt\string|}Rest_Update]) \Sneck{}
Length_Below $<$ Length,
!,
update_length(Length,Rest,Rest_Update).
\end{quote}

\begin{quote}
\% First length above length
update_length(Length,[(Length_Above,Count){\tt\string|}Rest],[(Length,1),(Length_Above,Count){\tt\string|}Rest]) \Sneck{}
Length $<$ Length_Above,
!.
\end{quote}

\% \predref{get_init}{2}

\begin{quote}
get_init(nucleotide,[(a,0),(c,0),(g,0),(t,0)]) \Sneck{}
!.
\end{quote}

\begin{center}
get_init(codon,[([a,a,a],0),([a,a,c],0),([a,a,g],0),([a,a,t],0),
([a,c,a],0),([a,c,c],0),([a,c,g],0),([a,c,t],0),
([a,g,a],0),([a,g,c],0),([a,g,g],0),([a,g,t],0),
([a,t,a],0),([a,t,c],0),([a,t,g],0),([a,t,t],0),
([c,a,a],0),([c,a,c],0),([c,a,g],0),([c,a,t],0),
([c,c,a],0),([c,c,c],0),([c,c,g],0),([c,c,t],0),
([c,g,a],0),([c,g,c],0),([c,g,g],0),([c,g,t],0),
([c,t,a],0),([c,t,c],0),([c,t,g],0),([c,t,t],0),
([g,a,a],0),([g,a,c],0),([g,a,g],0),([g,a,t],0),
([g,c,a],0),([g,c,c],0),([g,c,g],0),([g,c,t],0),
([g,g,a],0),([g,g,c],0),([g,g,g],0),([g,g,t],0),
([g,t,a],0),([g,t,c],0),([g,t,g],0),([g,t,t],0),
([t,a,a],0),([t,a,c],0),([t,a,g],0),([t,a,t],0),
([t,c,a],0),([t,c,c],0),([t,c,g],0),([t,c,t],0),
([t,g,a],0),([t,g,c],0),([t,g,g],0),([t,g,t],0),
([t,t,a],0),([t,t,c],0),([t,t,g],0),([t,t,t],0)
]) \Sneck{}
!.
\end{center}

\begin{center}
get_init(amino_acid,[(a,0),(c,0),(d,0),(e,0),
(f,0),(g,0),(h,0),(i,0),
(k,0),(l,0),(m,0),(n,0),
(p,0),(q,0),(r,0),(s,0),
(t,0),(v,0),(w,0),(y,0)
])\Sneck{}
!.
\end{center}

\% get_past(++Type,--Values).

get_past(nucleotide,a).
get_past(nucleotide,c).
get_past(nucleotide,g).
get_past(nucleotide,t).

get_past(codon,[a,a,a]).
get_past(codon,[a,a,c]).
get_past(codon,[a,a,g]).
get_past(codon,[a,a,t]).
get_past(codon,[a,c,a]).
get_past(codon,[a,c,c]).
get_past(codon,[a,c,g]).
get_past(codon,[a,c,t]).
get_past(codon,[a,g,a]).
get_past(codon,[a,g,c]).
get_past(codon,[a,g,g]).
get_past(codon,[a,g,t]).
get_past(codon,[a,t,a]).
get_past(codon,[a,t,c]).
get_past(codon,[a,t,g]).
get_past(codon,[a,t,t]).
get_past(codon,[c,a,a]).
get_past(codon,[c,a,c]).
get_past(codon,[c,a,g]).
get_past(codon,[c,a,t]).
get_past(codon,[c,c,a]).
get_past(codon,[c,c,c]).
get_past(codon,[c,c,g]).
get_past(codon,[c,c,t]).
get_past(codon,[c,g,a]).
get_past(codon,[c,g,c]).
get_past(codon,[c,g,g]).
get_past(codon,[c,g,t]).
get_past(codon,[c,t,a]).
get_past(codon,[c,t,c]).
get_past(codon,[c,t,g]).
get_past(codon,[c,t,t]).
get_past(codon,[g,a,a]).
get_past(codon,[g,a,c]).
get_past(codon,[g,a,g]).
get_past(codon,[g,a,t]).
get_past(codon,[g,c,a]).
get_past(codon,[g,c,c]).
get_past(codon,[g,c,g]).
get_past(codon,[g,c,t]).
get_past(codon,[g,g,a]).
get_past(codon,[g,g,c]).
get_past(codon,[g,g,g]).
get_past(codon,[g,g,t]).
get_past(codon,[g,t,a]).
get_past(codon,[g,t,c]).
get_past(codon,[g,t,g]).
get_past(codon,[g,t,t]).
get_past(codon,[t,a,a]).
get_past(codon,[t,a,c]).
get_past(codon,[t,a,g]).
get_past(codon,[t,a,t]).
get_past(codon,[t,c,a]).
get_past(codon,[t,c,c]).
get_past(codon,[t,c,g]).
get_past(codon,[t,c,t]).
get_past(codon,[t,g,a]).
get_past(codon,[t,g,c]).
get_past(codon,[t,g,g]).
get_past(codon,[t,g,t]).
get_past(codon,[t,t,a]).
get_past(codon,[t,t,c]).
get_past(codon,[t,t,g]).
get_past(codon,[t,t,t]).

get_past(amino_acid,a).
get_past(amino_acid,c).
get_past(amino_acid,d).
get_past(amino_acid,e).
get_past(amino_acid,f).
get_past(amino_acid,g).
get_past(amino_acid,h).
get_past(amino_acid,i).
get_past(amino_acid,k).
get_past(amino_acid,l).
get_past(amino_acid,m).
get_past(amino_acid,n).
get_past(amino_acid,p).
get_past(amino_acid,q).
get_past(amino_acid,r).
get_past(amino_acid,s).
get_past(amino_acid,t).
get_past(amino_acid,v).
get_past(amino_acid,w).
get_past(amino_acid,y).

\% build_past

\begin{quote}
build_past(Order,[],_-_,_Data) \Sneck{}
Order$>$0,
!,
fail.
\end{quote}

\begin{quote}
build_past(0,Data,_Past-[],Data) \Sneck{}
!.
\end{quote}

\begin{quote}
build_past(N,[Elt{\tt\string|}Rest],Past1-Past2,Rest_Data) \Sneck{}
Past2 = [Elt{\tt\string|}Past3],
N1 is N-1,
build_past(N1,Rest,Past1-Past3,Rest_Data).
\end{quote}

\%--------
\% Normalization predicates
\%--------
\%\% normalize(+Type,+Counting,-Probabilities)
\%
\% Predicate used to normalize the result of a counting
\% Probabilies is a list composed of element with the format
\% \Sequal{}
\% (Past,(Domain,Distribution))
\% \Sequal{}

\begin{quote}
normalize(Type,[],[]) \Sneck{}
member(Type,[nucleotide,codon,amino_acid]),
!.
\end{quote}

\begin{quote}
normalize(Type,[(Past,Countings){\tt\string|}Rest],[(Past,(Domain,Distribution)){\tt\string|}Rest_Normalized]) \Sneck{}
member(Type,[nucleotide,codon,amino_acid]),
!,
normalize2(Countings,0,0,_Length_Final,_Sum_Final,Domain,Distribution),
normalize(Type,Rest,Rest_Normalized).
\end{quote}

\begin{quote}
normalize(length,Counting_List,[([],(Domain,Distribution))]) \Sneck{}
normalize2(Counting_List,0,0,_Length_Final,_Sum_Final,Domain,Distribution).
\end{quote}

\begin{quote}
normalize2([],Length_Final,Sum_Final,Length_Final,Sum_Final,[],[]) \Sneck{}
!.
\end{quote}

\begin{quote}
normalize2([(Elt,Count){\tt\string|}Rest_Counting],Length,Sum,Length_Final,Sum_Final,[Elt{\tt\string|}Rest_Domain],[Proba{\tt\string|}Rest_Count]) \Sneck{}
New_Length is Length+1,
New_Sum is Sum+Count,
normalize2(Rest_Counting,New_Length,New_Sum,Length_Final,Sum_Final,Rest_Domain,Rest_Count),
(Sum_Final = 0 \Sifthen{}
Proba is 1/Length_Final \% To avoid division by zero, a uniform distribution is generated when Sum = 0
;
Proba is Count/Sum_Final
).
\end{quote}

\begin{quote}
normalized_rec([],Normalized_Switches,Normalized_Switches) \Sneck{}
!.
\end{quote}

\begin{quote}
normalized_rec([(Transition,Counter){\tt\string|}Rest],Normalized_Int,Normalized_Switches) \Sneck{}
!,
Transition \Suniv{} [_,Begin,End],
update_normalized(Normalized_Int,Begin,End,Counter,Normalized_Int1),
normalized_rec(Rest,Normalized_Int1,Normalized_Switches).
\end{quote}

\begin{quote}
update_normalized([],Begin,End,Counter,[(Begin,[End],[Counter])]) \Sneck{}
!.
\end{quote}

\begin{quote}
update_normalized([(Begin,Rest_End,Rest_Counter){\tt\string|}Rest],Begin,End,Counter,[(Begin,[End{\tt\string|}Rest_End],[Counter{\tt\string|}Rest_Counter]){\tt\string|}Rest]) \Sneck{}
!.
\end{quote}

\begin{quote}
update_normalized([(B,B_End,B_Counter){\tt\string|}Rest],Begin,End,Counter,[(B,B_End,B_Counter){\tt\string|}Rest_Result]) \Sneck{}
!,
update_normalized(Rest,Begin,End,Counter,Rest_Result).
\end{quote}

\begin{quote}
normalized2([],[]) \Sneck{}
!.
\end{quote}

\begin{quote}
normalized2([(Begin,Domain,Counters){\tt\string|}Rest],[(Begin,Domain,Distribution){\tt\string|}Rest_Result]) \Sneck{}
sum_list(Counters,Sum),
normalized3(Sum,Counters,Distribution),
normalized2(Rest,Rest_Result).
\end{quote}

\begin{quote}
normalized3(_Sum,[],[]) \Sneck{}
!.
\end{quote}

\begin{quote}
normalized3(Sum,[V{\tt\string|}Rest],[Proba{\tt\string|}Rest_Proba]) \Sneck{}
!,
Proba is V/Sum,
normalized3(Sum,Rest,Rest_Proba).
\end{quote}

\begin{quote}
sum_list([],0) \Sneck{}
!.
\end{quote}

\begin{quote}
sum_list([T{\tt\string|}Rest],Sum) \Sneck{}
!,
sum_list(Rest,Sum1),
Sum is T+Sum1.
\end{quote}

\%\% build_stat_facts(+Stats,-StatsFacts)
\% builds a list of facts, one for each statistic
\% \Sequal{}
\% build_stat_facts(
\% [([a],[(a,0),(c,1),(g,0),(t,0)]),([c],[(a,0),(c,0),(g,0),(t,1)]),([g],[(a,0),(c,0),(g,1),(t,2)]),([t],[(a,1),(c,0),(g,2),(t,1)])],
\% [stat([a,a],0),stat([a,c],1),stat([a,g],0),stat([a,t],0),stat([c,a],0),stat([c,c],0),stat([c,g],0),
\% stat([c,t],1),stat([g,a],0),stat([g,c],0),stat([g,g],1),stat([g,t],2),stat([t,a],1),stat([t,c],0),stat([t,g],2),stat([t,t],1)]
\% )
\% \Sequal{}

\begin{quote}
\% Version for counts:
build_stat_facts([],[]).
build_stat_facts([(PastList,CountsList){\tt\string|}StatRest],Facts) \Sneck{}
build_stat_facts_single(PastList,CountsList,FactsList),
build_stat_facts(StatRest,FactsListRest),
append(FactsList,FactsListRest,Facts).
\end{quote}

\begin{quote}
\% Version for normalized stats:
build_stat_facts([(Past,(Present,Counts)){\tt\string|}StatRest],Facts) \Sneck{}
build_stat_facts_combine_lists(Present,Counts,Combined),
build_stat_facts([(Past,Combined){\tt\string|}StatRest],Facts).
\end{quote}

build_stat_facts_single(_,[],[]).

\begin{quote}
build_stat_facts_single(PastList,[(N,Count){\tt\string|}Rest], [stat(Full,Count){\tt\string|}FactsRest]) \Sneck{}
append(PastList,[N],Full),
build_stat_facts_single(PastList,Rest,FactsRest).
\end{quote}

\begin{quote}
build_stat_facts_combine_lists([],[],[]).
build_stat_facts_combine_lists([A{\tt\string|}Ar], [B{\tt\string|}Br], [(A,B){\tt\string|}Cr]) \Sneck{}
build_stat_facts_combine_lists(Ar,Br,Cr).
\end{quote}

\% Normalize stat facts

\begin{center}
normalize_stat_facts(Facts,NormalizedFacts) \Sneck{}
count_all(Facts,TotalCount),
((TotalCount \Sequal{} 0) \Sifthen{}
NormalizedFacts = Facts
;
normalize_stat_facts(Facts,TotalCount,NormalizedFacts)).
\end{center}

\begin{quote}
normalize_stat_facts([],_,[]).
normalize_stat_facts([stat(NGram,Count){\tt\string|}Rest],TotalCount,[stat(NGram,Norm){\tt\string|}NormRest]) \Sneck{}
Norm is Count / TotalCount,
normalize_stat_facts(Rest,TotalCount,NormRest).
\end{quote}

\begin{quote}
count_all([],0).
count_all([stat(_,Count){\tt\string|}Rest],TotalCount) \Sneck{}
count_all(Rest,CountRest),
TotalCount is Count + CountRest.
\end{quote}

